My Alternate Collision strategy take the sum of the ascii values of the key
and subtracts the bytesize of the same string. I add in a multiplier for good measure.
The index grows twice as.  quickly in this scenario

def index(key, size)
    diff = key.sum - key.bytesize * 2
    diff % size
  end




Collision Resolution Strategies
Source: https://courses.cs.washington.edu/courses/cse373/01sp/Lect13.pdf

Quadratic Probing- Instead of using the open addressing linear probing strategy, we use a larger spread for
empty slots using square products. Avoids most primary clustering.

Double hashing- Another form of open addressing. Uses a secondary hash function when a collision occurs.
Slower than quadratic probing


Extendible Hashing- Used when large databases are stored on disks. Data is stored using bit patterns



Hash_State output after:
star_wars_movies = SeparateChaining.new(6)
  star_wars_movies["Star Wars: The Phantom Menace"] = "Number One"
  star_wars_movies["Star Wars: Attack of the Clones"] = "Number Two"
  star_wars_movies["Star Wars: Revenge of the Sith"] = "Number Three"
  star_wars_movies["Star Wars: A New Hope"] = "Number Four"
  star_wars_movies["Star Wars: The Empire Strikes Back"] = "Number Five"
  star_wars_movies["Star Wars: Return of the Jedi"] = "Number Six"


Current Load Factor: 0.5
INDEX 2
Key= Star Wars: The Empire Strikes Back Value= Number Five
INDEX 3
Key= Star Wars: Attack of the Clones Value= Number Two
INDEX 4
Key= Star Wars: A New Hope Value= Number Four
INDEX 6
Key= Star Wars: The Phantom Menace Value= Number One
INDEX 11
Key= Star Wars: Revenge of the Sith Value= Number Three
